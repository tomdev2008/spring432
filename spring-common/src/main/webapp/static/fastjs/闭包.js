/*
   #理解和用好js的闭包是js高级程序员的必备
   #理解语言的特性，回调和return都可以专递一个对象(函数，对象本身)
*/
function a(){
   var i=100;
   
   return function(){/*这是一个闭包结构的函数定义，不是闭包*/
      alert("i="+i);
   };
};

/*
	当函数内部函数被函数外的一个变量引用的时候，就创建了一个闭包
*/
/*封装*/
var person = function(){    
	
    /*变量作用域为函数内部，外部无法访问*/  
    var name = "default";       
     
    return {    
       getName : function(){    
           return name;    
       },    
       setName : function(newName){    
           name = newName;    
       }    
    };  
}(); 

/*继承*/
var Jack = function(){
	
};

//继承自Person
Jack.prototype = new Person();

//添加私有方法
Jack.prototype.Say = function(){
    alert("Hello,my name is Jack");
};


/*
 	匿名函数:
 		匿名函数是指没有指定函数名称的函数(初始化和隔离作用域)
 		匿名函数自执行时定义对象，定义的对象用到了匿名函数的局部变量，但是对于这个对象来说，这个变量却是全局的
 		
	闭包：
		通常来讲可以简单的认为是可以访问一个函数里面的局部变量的另外一个函数
		闭包函数体在外部函数执行的时候是不执行的
		闭包里的this指向的是window
		闭包引起的内存泄漏，浏览器关闭才释放内存!!!
		
		问题:在子作用域中保存了一份在父级作用域取得的变量，这些变量不会随父级作用域的
		           销毁而销毁，因为他们已经常驻内存了
			1:因为常驻内存所以会造成内存泄露
			2:只要其他作用域能取到子作用域的访问接口，那么其他作用域就有方法访问该子作用域父级作用域的变量了
 */
(function(){
	alert('anonymous');
})();

(function(v){
    alert('anonymous ' + v);
})('test'); 


/*
  	 1.典型的函数声明：  
     function functionName(arg0,arg1,arg2){  
         //函数体  
     } 
      
     2.函数表达式:  
     var functionName = function(arg0,arg1,arg2){  
         //函数体  
     }  
     
     区别:
     	区别1：前者会在代码执行以前被加载到作用域中，而后者则是在代码执行到那一行的时候才会有意义
		区别2：前者会给函数指定一个名字，而后者则是创建一个匿名函数，然后将这个匿名函数赋给一个变量
       		   换句话说上面第二个例子：创建了一个带有3个参数的匿名函数，然后把这个匿名函数赋给了变
       		   量functionName，并没有给匿名函数指定名字
       		   
   
   闭包:指有权访问另一个函数作用域中的变量的函数 
              闭包就是将函数内部和函数外部连接起来的一座桥梁
  
  意义: 函数和变量的作用域
               注意:函数内部声明变量的时候，一定要使用var命令
               如果不用的话，你实际上声明了一个全局变量
 
 	 闭包:如何从外部读取局部变量呢?
 	 
     用途:
     1. 可以读取函数内部的变量
     2. 可以让这些变量的值始终保持在内存中
 
    优缺点:
	1.保护函数内的变量安全,加强了封装性 
	2.在内存中维持一个变量(用的太多就变成了缺点，占内存)
	
    不适合场景：返回闭包的函数是个非常大的函数
    适合:设计私有的方法和变量,适合框架设计
    
    能不用就不用，如果非用不可，那就想办法保持闭包对象的数量很少
 */
// 函数a
function a() {
	var i = 0;
	// 函数b
	function b() {
		alert(++i);
	}
	return b;
}

// 函数c
var c = a();
c();



